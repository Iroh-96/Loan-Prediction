# -*- coding: utf-8 -*-
"""Loan Prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NnpF8JDj-MHxtM_uRUxu3GiKR9OShM9F
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np 
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns
sns.set(style="white", color_codes=True)

# Importing the dataset by giving the path and displaying first 10 values

df = pd.read_csv("/content/train.csv")
df.head(10)

# Describing entire Dataset 

df.describe()

# Obtaining all the information 

df.info()

# Checking rows and Columns of dataset

df.shape

# checking the existance of Null values in each column

df.isnull().any()

df.isnull().sum()

# To check the number of outcomes in a particular column (Represented in form of array)

df["Property_Area"].unique()

# Count of occurance of each outcome of a column

df["Property_Area"].value_counts()

df['Dependents'].fillna(1,inplace=True)
df['LoanAmount'].fillna(df.LoanAmount.mean(),inplace = True)
Value_Mapping = {'Yes' : 1, 'No' : 0}
df['Married_Section'] = df['Married'].map(Value_Mapping)
Value_Mapping1 = {'Male' : 1, 'Female' : 0}
df['Gender_Section'] = df['Gender'].map(Value_Mapping1)
Value_Mapping2 = {'Graduate' : 1, 'Not Graduate' : 0}
df['Edu_Section'] = df['Education'].map(Value_Mapping2)
df["Married_Section"].fillna(df.Married_Section.mean(),inplace=True) 
df["Gender_Section"].fillna(df.Gender_Section.mean(),inplace=True)
df["Loan_Amount_Term"].fillna(df.Loan_Amount_Term.mean(),inplace=True)
df["Credit_History"].fillna(df.Credit_History.mean(),inplace=True)
Value_Mapping3 = {'Yes' : 1, 'No' : 0}
df['Employed_Section'] = df['Self_Employed'].map(Value_Mapping3)
df["Employed_Section"].fillna(df.Employed_Section.mean(),inplace=True)

df.info()

# Filling the empty spaces of the column having more than 2 outcomes in character form.

from sklearn.preprocessing import LabelEncoder

lb_make = LabelEncoder()
df["Property_Section"] = lb_make.fit_transform(df["Property_Area"])
df.head(5)

Value_Mapping4 = {'Y' : 1, 'N' : 0}
df['Loan_Section'] = df['Loan_Status'].map(Value_Mapping4)
df.head(5)

# Dependents Column is not used in data representation and algorithm implementation

# Using SCATTER REPRESENTATION
# Imported libraries... x-axis: loan_status, y_axis: Loan_Amount and representing in terms of Gender_Section

sns.FacetGrid(df,hue="Gender_Section",size=4) \
.map(plt.scatter,"Loan_Status","LoanAmount") \
.add_legend()
plt.show()

# x-axis: ApplicationIncome, y_axis: CoapplicantIncome and representing in terms of Property_Section

sns.FacetGrid(df,hue="Property_Section",size=4) \
.map(plt.scatter,"ApplicantIncome","CoapplicantIncome") \
.add_legend()
plt.show()

# Using HISTOGRAM REPRESENTATION
# x-axis: loan figures, y_axis: count, Title: Loan taken by Customers

plt.figure(figsize = (10,7)) 
x = df["LoanAmount"] 
plt.hist(x, bins = 30, color = "pink") 
plt.title("Loan taken by Customers") 
plt.xlabel("Loan Figures") 
plt.ylabel("Count")

#USING BOXPLOT REPRESENTATION
# x-axis: Property_Area with 3 types of outcomes, y-axis: Gender_Section with 3 types of outcomes

sns.boxplot(x="Property_Area", y="Gender_Section", data=df)

# x-axis: Married_Section with 3 types of outcomes, y-axis: ApplicantIncome with all outcomes

sns.boxplot(x="Married_Section", y="ApplicantIncome", data=df)

df_temp=df[df["Education"]== "Graduate"]
df_temp["Self_Employed"].hist()

sns.FacetGrid(df, hue="Credit_History", size=6).map(sns.kdeplot, "CoapplicantIncome").add_legend()

cols = ['ApplicantIncome','CoapplicantIncome','LoanAmount','Loan_Amount_Term','Credit_History','Married_Section',
        'Gender_Section','Edu_Section','Employed_Section','Property_Section']
f, ax = plt.subplots(figsize=(10, 7))
cm = np.corrcoef(df[cols].values.T)
sns.set(font_scale=1.5)
hm = sns.heatmap(cm,
                 cbar=True,
                 annot=True,
                 square=True,
                 fmt='.2f',
                 annot_kws={'size': 15},
                 yticklabels=cols,
                 xticklabels=cols)

plt.show()

# Importing Libraries and classes

from sklearn.linear_model import LogisticRegression
model = LogisticRegression()

X=df[['ApplicantIncome','CoapplicantIncome','LoanAmount','Loan_Amount_Term','Credit_History','Married_Section',
        'Gender_Section','Edu_Section','Employed_Section','Property_Section']].values
y=df[["Loan_Section"]].values

# Dividing the data in 7:3 Ratio for Training and Testing respectively

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0)

# Training the Model

model.fit(X_train,y_train)

# Training Accuracy

model.score(X_train,y_train)

#Testing Accuracy

model.score(X_test,y_test)

# Y contains all the outputs and X contains all the inputs. We will test on the machine if it gives to expected Output for the 
# corresponding Inputs.

expected = y_test
predicted = model.predict(X_test)

# Importing Libraries and class 

from sklearn import metrics
#  Printing the Report

print(metrics.classification_report(expected, predicted))

# Importing libraries and classes

from sklearn.ensemble import RandomForestClassifier
model= RandomForestClassifier()

# Training the model

model.fit(X_train,y_train)

# Accuracy in training the model

model.score(X_train,y_train)

#Accuracy in testing the model

model.score(X_test,y_test)

# Y contains all the outputs and X contains all the inputs. We will test on the machine if it gives to expected Output for the 
# corresponding Inputs.

expected = y_test
predicted = model.predict(X_test)

# Generating Report

print(metrics.classification_report(expected, predicted))

# Output in the form of Matrix

print(metrics.confusion_matrix(expected, predicted))

test = pd.read_csv("/content/test.csv")
test2 = pd.read_csv("/content/test.csv")
## print shape of dataset with rows and columns
print(test.shape)

test.isna().sum()

test['Dependents'].fillna(1,inplace=True)
test['LoanAmount'].fillna(test.LoanAmount.mean(),inplace = True)
Value_Mapping = {'Yes' : 1, 'No' : 0}
test['Married_Section'] = test['Married'].map(Value_Mapping)
Value_Mapping1 = {'Male' : 1, 'Female' : 0}
test['Gender_Section'] = test['Gender'].map(Value_Mapping1)
Value_Mapping2 = {'Graduate' : 1, 'Not Graduate' : 0}
test['Edu_Section'] = test['Education'].map(Value_Mapping2)
test["Married_Section"].fillna(test.Married_Section.mean(),inplace=True) 
test["Gender_Section"].fillna(test.Gender_Section.mean(),inplace=True)
test["Loan_Amount_Term"].fillna(test.Loan_Amount_Term.mean(),inplace=True)
test["Credit_History"].fillna(test.Credit_History.mean(),inplace=True)
Value_Mapping3 = {'Yes' : 1, 'No' : 0}
test['Employed_Section'] = test['Self_Employed'].map(Value_Mapping3)
test["Employed_Section"].fillna(test.Employed_Section.mean(),inplace=True)
from sklearn.preprocessing import LabelEncoder
lb_make = LabelEncoder()
test["Property_Section"] = lb_make.fit_transform(test["Property_Area"])

test.isna().sum()

test.dtypes

test=test.drop(columns=['Gender','Self_Employed','Loan_ID','Married','Dependents','Education','Self_Employed','Property_Area'])

predictedtest = model.predict(test)

predictedtest.tolist()
#Updating to the test data set
test['Loan_Status']=predictedtest

test2['Loan_Status']=predictedtest

test2.head()

test2.shape

Value_Mapping4 = {1 : 'Y', 0 : 'N'}
test2['Loan_Status'] = test['Loan_Status'].map(Value_Mapping4)

test2.head()

